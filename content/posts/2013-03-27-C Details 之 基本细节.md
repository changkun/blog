---
date: "2013-03-27 23:42:21"
toc: true
id: 91
slug: /posts/c-details-之-基本细节
aliases:
    - /archives/2013/03/91/
tags:
    - C
title: C Details 之 基本细节
---

# 1、有效数字

一般而言，double型数据可以接受实型常量的16位有效数字，而float型变量仅能接受实型常量的7位有效数字，
在有效数字后面输出的数字都是不准确的。

例如：

``` c
float  a = 123456.7890123456e12;
double b = 123456.7890123456e12;
```

可以尝试：

``` c
printf("%f\n%f\n",a,b);
```

<!-- more -->

# 2、变量定义的位置

C语言中要求定义变量必须在所有可执行语句之前。

例如：

``` c
printf("Input n:");
int n;
scanf("%d",&n);
```

这一规定仅仅只是在C89中规定，从C99开始便取消了这一规定并且，C++也并没有这一规定，例如：

``` c
for( int i = 0; i < Num; i++ )
    Do something;
```

# 3、关于自增

一个疑问：对于

``` c
a = 1;
b = a++;
c = ++a;
```

为什么b的值为1，c的值为2？

先解答为什么会出现这个问题：

因为根据C运算符的优先级与结合性可以知道，++运算符的优先级是高于=运算符的。

再来解答这是为什么：

`b = a++;` 的实际效果是 `b = a;a = a + 1;` 但是之前我们提到，其实++运算符的优先级是高于=运算符的，
但是为什么没有发生 b 的值为 2 的情况，这是因为如果按照这一优先级，`b = a++` 则会变成 `(b = a)++`，
这样的话就违背了语言的本意。总结来说就是，这类情况属于 C 语言未定义的那部分东西，就好像 `j++ + ++j` 
这种无聊的东西结果是会和编译器有关系的，它本身就包涵错误。最好的解决办法是：尽量使用括号。

# 4、一些常用的格式转换说明符

函数printf()的格式转换说明符

|符号|说明|
|:--|:--|
|%d|输出带符号的十进制整数。|
|%u|以无符号的十进制整数形式输出。|
|%o|以无符号的八进制整数心事输出，不输出前导符0（八进制整数由0开头）。|
|%x|以无符号十六进制整数形式（小写）输出，不输出前导符0x。|
|%X|以无符号十六进制整数形式（大写）输出，不输出前导符0x。|
|%e|以指数形式（小写e表示指数部分）输出实数，要求小数点前必须有且仅有一位非零数字。|
|%E|以指数形式（大写E表示指数部分）输出实数。|

# 5、随机函数rand()

随机函数rand()产生的是一个在 0~RAND_MAX之间的整数，符号常量RAND_MAX是在头文件stdlib.h中

定义的，因此使用该函数时需要包涵头文件stdlib.h

标准C规定RAND_MAX的值不大于双字节整数的最大值32767。

可以采用下面方法来控制计算机生成的随机数的取值范围：

1. 利用取余运算rand()%b将函数rand()生成的随机数变化到0~b-1之间。

2. 利用rand()%b+a运算将随机数取值范围平移到[a,a+b-1]之间。

实际上，函数 rand 所产生的随机数其实只是一个伪随机数，反复调用函数rand()所残生的一些列数看似是随机的，但每次执行程序所产生的随机数序列却是一样的，都是相同的一个数列，而程序又每次值用到了数列中的第一个随机数。

解决这个问题的办法是使程序每次运行时产生不同的随机数列。残生这种随机数的过程称为“随机化”，他是通过调用标准库函数 srand() 为函数 rand() 设置随机数种子来实现的。它的原型为：

``` c
void srand(unsigned seed);
```

但是这个的弊端就是每次都必须通过向 `srand()` 传入一个随机数种子来完成随机化。在头文件 `<time.h>` 中的函数 `time()` 返回以秒计算的当前时间值，即一个代表时间的字符串，使用 NULL 作为 time() 的参数时，time(NULL) 的返回值被转换为一个无符号整数，可以作为随机数发生器种子。因此我们可以通过编写

``` c
srand( time(NULL) );
```